package com.ua.hiah.service.source.database;

import com.ua.hiah.model.source.SourceDatabase;
import com.ua.hiah.model.source.SourceField;
import com.ua.hiah.model.source.SourceTable;
import com.ua.hiah.model.source.ValueCount;
import com.ua.hiah.rabbitcore.utilities.ScanFieldName;
import com.ua.hiah.rabbitcore.utilities.ScanSheetName;
import com.ua.hiah.rabbitcore.utilities.files.QuickAndDirtyXlsxReader;
import com.ua.hiah.rabbitcore.utilities.files.QuickAndDirtyXlsxReader.Row;
import com.ua.hiah.rabbitcore.utilities.files.QuickAndDirtyXlsxReader.Sheet;
import com.ua.hiah.repository.source.SourceDatabaseRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

@Service
public class SourceDatabaseServiceImpl implements SourceDatabaseService {

    @Autowired
    private SourceDatabaseRepository databaseRepository;


    /**
     * Reads Scan report generated by White Rabbit and persists its information
     *
     * @param name EHR database name
     * @param file Scan report file
     * @return Source Database (with its tables, fields and value counts)
     */

    @Override
    public SourceDatabase createDatabaseFromScanReport(String name, MultipartFile file) {
        /* Adapted from Database (rabbit-core) */
        SourceDatabase database = new SourceDatabase(name);
        try {
            // write content in a file
            File scanTemp = new File("scanTemp.xlsx");
            if(scanTemp.createNewFile()) {
                OutputStream os = new FileOutputStream(scanTemp);
                os.write(file.getBytes());
                os.close();
            }
            List<SourceTable> tables = new ArrayList<>();
            QuickAndDirtyXlsxReader workbook = new QuickAndDirtyXlsxReader(scanTemp.getAbsolutePath());
            // Create table lookup from tables overview, if it exists
            Map<String, SourceTable> nameToTable = createTablesFromTableOverview(workbook, database);
            // Field overview is the first sheet
            Sheet overviewSheet = workbook.getByName(ScanSheetName.FIELD_OVERVIEW);
            if (overviewSheet == null) {
                overviewSheet = workbook.get(0);
            }
            Iterator<Row> overviewRows = overviewSheet.iterator();
            // skip header
            overviewRows.next();
            while(overviewRows.hasNext()) {
                Row row = overviewRows.next();
                String tableName = row.getStringByHeaderName(ScanFieldName.TABLE);
                if (tableName.length() != 0) {
                    // Get table created from table overview or created before
                    SourceTable table = nameToTable.get(tableName);
                    if (table == null) {
                        table = new SourceTable(
                            tableName,
                            row.getIntByHeaderName(ScanFieldName.N_ROWS),
                            row.getIntByHeaderName(ScanFieldName.N_ROWS_CHECKED),
                            database
                        );
                        // Add to lookup and database
                        nameToTable.put(tableName, table);
                    }
                    tables.add(table);
                    SourceField field = new SourceField(
                        row.getStringByHeaderName(ScanFieldName.FIELD).toLowerCase(),
                        row.getByHeaderName(ScanFieldName.TYPE),
                        row.getIntByHeaderName(ScanFieldName.MAX_LENGTH),
                        row.getDoubleByHeaderName(ScanFieldName.FRACTION_EMPTY),
                        row.getIntByHeaderName(ScanFieldName.UNIQUE_COUNT) == null ? -1 : row.getIntByHeaderName(ScanFieldName.UNIQUE_COUNT),
                        row.getDoubleByHeaderName(ScanFieldName.FRACTION_UNIQUE) == null ? -1 : row.getDoubleByHeaderName(ScanFieldName.FRACTION_UNIQUE),
                        table
                    );
                    table.getFields().add(field);

                    Map<String, Integer> valueCounts = getValueCounts(workbook, table, row.getStringByHeaderName(ScanFieldName.FIELD));
                    if (valueCounts != null) {
                        int totalCount = valueCounts.values().stream().reduce(0, Integer::sum);
                        for (Map.Entry<String, Integer> entry : valueCounts.entrySet()) {
                            ValueCount valueCount = new ValueCount(
                                entry.getKey(),
                                entry.getValue(),
                                entry.getValue() / (double) totalCount,
                                field
                            );
                            field.getValueCounts().add(valueCount);
                        }
                    }
                }
            }
            database.setTables(tables);
            scanTemp.delete();
            return databaseRepository.save(database);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    @Override
    public SourceDatabase createDatabaseFromJSON(SourceDatabase sourceDatabase) {
        SourceDatabase response = new SourceDatabase(sourceDatabase.getDatabaseName());
        List<SourceTable> tables = new ArrayList<>();
        for (SourceTable table : sourceDatabase.getTables()) {
            SourceTable responseTable = new SourceTable(
                table.getName(),
                table.getRowCount(),
                table.getRowsCheckedCount(),
                table.getComment(),
                response
            );
            tables.add(responseTable);

            for (SourceField field : table.getFields()) {
                SourceField responseField = new SourceField(
                    field.getName(),
                    field.getType(),
                    field.getMaxLength(),
                    field.getFractionEmpty(),
                    field.getUniqueCount(),
                    field.getFractionUnique(),
                    field.getComment(),
                    responseTable
                );
                responseTable.getFields().add(responseField);

                for (ValueCount valueCount : field.getValueCounts()) {
                    ValueCount responseValue = new ValueCount(
                            valueCount.getValue(),
                            valueCount.getFrequency(),
                            valueCount.getPercentage(),
                            responseField
                    );
                    responseField.getValueCounts().add(responseValue);
                }
            }
        }

        response.setTables(tables);
        return databaseRepository.save(response);
    }


    /**
     * Create source database tables
     *
     * @param workbook Xlsx file
     * @param database Source database
     * @return map with tables
     */

    private Map<String, SourceTable> createTablesFromTableOverview(QuickAndDirtyXlsxReader workbook, SourceDatabase database) {
        /* Adapted from Database (rabbit-core) */
        QuickAndDirtyXlsxReader.Sheet tableOverviewSheet = workbook.getByName(ScanSheetName.TABLE_OVERVIEW);
        List<SourceTable> tables = new ArrayList<>();
        if (tableOverviewSheet == null)      // No table overview sheet, empty nameToTable
            return new HashMap<>();

        Map<String, SourceTable> nameToTable = new HashMap<>();
        Iterator<QuickAndDirtyXlsxReader.Row> tableRows = tableOverviewSheet.iterator();
        tableRows.next();  // Skip header
        while (tableRows.hasNext()) {
            QuickAndDirtyXlsxReader.Row row = tableRows.next();
            String tableName = row.getByHeaderName(ScanFieldName.TABLE);
            String description = row.getByHeaderName(ScanFieldName.DESCRIPTION);
            int nRows = row.getIntByHeaderName(ScanFieldName.N_ROWS);
            int nRowsChecked = row.getIntByHeaderName(ScanFieldName.N_ROWS_CHECKED);
            SourceTable table = new SourceTable(tableName, nRows, nRowsChecked, database);
            // Add to lookup and database
            nameToTable.put(tableName, table);
            tables.add(table);
        }
        database.setTables(tables);
        return nameToTable;
    }


    /**
     * Get the value counts for field
     *
     * @param workbook xlsx reader
     * @param table table
     * @param fieldName field
     * @return map with each value and its count
     */

    private static Map<String, Integer> getValueCounts(QuickAndDirtyXlsxReader workbook, SourceTable table, String fieldName) {
        /* Adapted from Database (rabbit-core) */
        String targetSheetName = table.createSheetNameFromTableName(table.getName());
        Sheet tableSheet = workbook.getByName(targetSheetName);

        if (tableSheet == null) {
            return null;
        }

        Map<String, Integer> valueCounts = new HashMap<>();
        Iterator<Row> iterator = tableSheet.iterator();
        Row header = iterator.next();
        int index = header.indexOf(fieldName);
        if (index != -1) {
            while (iterator.hasNext()) {
                Row row = iterator.next();
                if (row.size() > index) {
                    String value = row.get(index);
                    String count;

                    if (row.size() > index + 1)
                        count = row.get(index + 1);
                    else
                        count = "";

                    if (value.equals("") && count.equals(""))
                        break;

                    try {
                        valueCounts.put(value, (int) Double.parseDouble(count));
                    } catch (NumberFormatException e) { }
                }
            }
        }
        return valueCounts;
    }
}
